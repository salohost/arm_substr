.global del_substr

del_substr:
	push {r4-r7, lr}	@ Нужно сохранить значения этих регистров
	mov r3, r0		@ Курсор для записи
	ldrb r5, [r1]		@ Берем первый символ подсроки
	b outside		@ Переходим в состояние "вне подстроки"

not_found:
				@ В случае, если потенциальная подстрока
	pop {r7}		@ вовсе не подстрока, то сохраненный указатель
				@ на начало вытаскиваем из стека и забываем.

	cmp r4, r5		@ Если мы снова попали на первый символ подстроки: 
	beq go_inside		@ Возвращаемся в состояние "в потенциальной подстроке"
	b outside		@ Иначе в состояние "вне подстроки"

found:
	pop {r7}		@ Если подстрока найдена, то вспоминаем ее начало
	mov r3, r7		@ И устанавливаем курсор для записи на это начало

outside:
	ldrb r4, [r0], #1	@ Достаем символ из под курсора для чтения
	strb r4, [r3], #1	@ Пишем этот символ под курсор для записи

	cmp r4, #0		@ Увидели конец строки
	beq exit		@ поэтому выходим
	
	cmp r4, r5		@ Если не нашли первый символ подстроки
	bne outside		@ то остаемся в состоянии "вне подстроки"

go_inside:			@ Переходим в состояние "в потенциальной подстроке"
	sub r7, r3, #1		@ 
	push {r7}		@ Сохраним позицию курсора для записи в стэк

	add r2, r1, #1		@ r2 будет соответсвущим курсором в подстроке
inside:
	ldrb r7, [r2], #1	@ Берем символ из под курсора подстроки

	cmp r7, #0		@ Если курсор подстроки указывает на конец подстроки
	beq found		@ То подстрока найдена

	ldrb r4, [r0], #1	@ Иначе читаем из курсора для чтения
	strb r4, [r3], #1	@ И пишем под курсор для записи
	
	cmp r4, #0		@ Если прочитали конец строки, то выходим
	beq pop_and_exit	@ (+ в стэке лежит ненужное начало подстроки)
	
	cmp r7, r4		@ Если значения под курсорами для подстроки для чтения
	bne not_found		@ не совпадают, то мы нашли не подстроку
	b inside		@ если же совпдают, то продолжаем сравнивать

pop_and_exit:
	pop {r7}			
exit:
	pop {r4-r7, lr}		@ Возвращаем регистры в исходное состояние
	bx lr			@ Завершаем вызов функции
